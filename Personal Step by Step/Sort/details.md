
# Sorting Algorithms Comparison

## 🔄 Bubble Sort
### ✅ Advantages:
- Simple to understand and implement
- Efficient for small datasets or nearly sorted data

### ❌ Disadvantages:
- Inefficient for large datasets
- High number of comparisons and swaps

### ⏱️ Complexity:
- Best: O(n)
- Average: O(n^2)
- Worst: O(n^2)
- Space Complexity: O(1)

## 🔄 Heap Sort
### ✅ Advantages:
- Efficient for large datasets
- In-place sorting algorithm

### ❌ Disadvantages:
- Not stable
- More complex to implement

### ⏱️ Complexity:
- Best: O(n log n)
- Average: O(n log n)
- Worst: O(n log n)
- Space Complexity: O(1)

## 🔄 Insertion Sort
### ✅ Advantages:
- Simple to implement
- Efficient for small datasets or nearly sorted data
- Stable sort

### ❌ Disadvantages:
- Inefficient for large datasets

### ⏱️ Complexity:
- Best: O(n)
- Average: O(n^2)
- Worst: O(n^2)
- Space Complexity: O(1)

## 🔄 Merge Sort
### ✅ Advantages:
- Efficient for large datasets
- Stable sort

### ❌ Disadvantages:
- Requires additional memory
- More complex to implement

### ⏱️ Complexity:
- Best: O(n log n)
- Average: O(n log n)
- Worst: O(n log n)
- Space Complexity: O(n)

## 🔄 Quick Sort
### ✅ Advantages:
- Efficient for large datasets
- In-place sorting algorithm

### ❌ Disadvantages:
- Not stable
- Worst-case performance can be poor

### ⏱️ Complexity:
- Best: O(n log n)
- Average: O(n log n)
- Worst: O(n^2)
- Space Complexity: O(log n)

## 🔄 Selection Sort
### ✅ Advantages:
- Simple to implement
- Performs well on small datasets

### ❌ Disadvantages:
- Inefficient for large datasets
- Not stable

### ⏱️ Complexity:
- Best: O(n^2)
- Average: O(n^2)
- Worst: O(n^2)
- Space Complexity: O(1)